# 实验报告
**14353104**   **黄新元**

**2016/10/20**

##实验结果截图
* 第一次跑的结果(count=20000，迭代101次)
  ![deadlock1](https://github.com/portal20/ES2016_14353104/blob/master/Pictures/deadlock1.png)

* 第二次跑的结果(count=20000，迭代101次)
  ![deadlock2](https://github.com/portal20/ES2016_14353104/blob/master/Pictures/deadlock2.png)

##产生死锁的四个条件
*  互斥条件。即在一段时间内某资源只由一个进程占用的情况下，如果此时还有其它进程请求资源，则请求方只能等待，直到占有资源的进程释放该资源。

*  请求和保持条件。指进程已经占用至少一个资源，但又提出了新的资源请求，而该资源已经被其它进程占有，此时请求进程阻塞，但是已经占用的资源仍保持不放。

*  不剥夺条件。指进程已占有的资源在未使用前不能被剥夺，只能在使用完后由自己释放。

*  循环等待条件。发生死锁时，必然存在一个进程和资源间的环路链。若干进程之间形成一种头尾相接的循环等待资源关系。


##死锁分析
原java程序主线程Main在`t.start()`执行后就产生一个子线程t。而操作系统对于进程的调度一般用的是RR（旋转罗宾）法，即每个进程都有一个固定长度的时间片，时间片结束后CPU执行就绪队列里的下一个进程。假设一种情况，在count结束后，主线程执行`a.methodA(b)`，则object b中的last方法被占用。根据synchronized的要求，对object b中的methodB方法的访问必须被阻塞。而恰巧的是，`a.methodA(b)`还没执行完（没有输出信息）时间片就用完了（count循环占的时间太久，和count值有关）。于是轮到了子线程执行，`b.methodB(a)`执行的时候被阻塞，所以一直等待直到自己的时间片又被耗完。又轮到主线程执行时，本来应该继续上次的地方继续输出信息的，但是由于object b的methodB方法又被子线程占有，所以对last方法的访问也被阻塞了，继续等待。就这样，主线程和子线程都在等待对方占有的资源被释放，最终形成死锁，整个程序卡死。

##实验感想
这次实验回顾了操作系统中介绍的死锁的概念和一些进程调度的知识。在进行多线程编程时，很关键的一个地方是不能出现死锁，否则容易导致整个程序崩溃。